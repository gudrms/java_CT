# 기술과제 피드백 분석 및 면접 대응 가이드

## 1. 피드백 분석 ("어디가 문제였나?"에 대한 답변)

받으신 피드백은 **긍정적인 평가(Good Points)** 위주로 되어 있습니다. 합격 통보와 함께 온 피드백이므로, **"문제가 있어서 지적받은 것"**이라기보다는 **"지원자님이 잘한 부분이라고 면접관이 인정한 포인트"**입니다.

하지만 면접에서는 **"잘한 부분"에 대해 더 깊이 물어보거나, 그 설계의 한계점(Trade-off)**을 질문하여 지원자의 깊이를 파악하려 할 것입니다. 즉, "여기가 문제다"가 아니라 **"이 선택을 왜 했고, 다른 대안은 무엇인지 아는가?"**를 검증하는 공격 포인트가 될 수 있습니다.

| 피드백 항목 | 면접관의 의도 및 예상 질문 포인트 |
|:---:|:---:|
| **SimpleServlet 인터페이스 추상화** | 서블릿 컨테이너의 핵심인 '생명주기(LifeCycle)'와 '요청 처리'를 잘 분리했는지 확인. <br>→ **예상 질문:** 왜 인터페이스로 만들었나? 표준 Servlet과 비교하면 무엇이 부족한가? |
| **Thread Pool 설정** | 무제한 스레드 생성(OOM 위험)을 방지하고 리소스를 제어할 줄 아는지 확인. <br>→ **예상 질문:** 왜 `FixedThreadPool`을 썼나? 요청이 스레드 수보다 많으면 어떻게 되나? BIO의 한계는? |
| **SecurityRule 추상화** | 객체지향 설계 원칙(OCP: 개방-폐쇄 원칙)을 잘 지키는지 확인. <br>→ **예상 질문:** 새로운 보안 규칙을 추가하려면? 규칙 간의 순서는 어떻게 제어하나? |

---

## 2. 상세 면접 대비 질문 (Technical Interview - 1시간)

### 2-1. [SimpleServlet] 서블릿 구조 및 싱글톤
피드백: *"SimpleServlet 인터페이스를 잘 추상화하셨고..."*

*   **Q1. `SimpleServlet`을 인터페이스로 설계한 이유는 무엇인가요?**
    *   **답변 가이드:** 구현체(Business Logic)와 실행 환경(Web Server)을 분리하기 위함입니다. 서버는 구체적인 로직을 몰라도 표준 인터페이스(`service()`)만 호출하면 되므로 확장성이 좋아집니다. (Strategy Pattern의 일종)
*   **Q2. `SimpleServlet` 구현체들은 싱글톤으로 관리되나요, 요청마다 생성되나요?**
    *   **분석:** 현재 `HttpServer.java`를 보면 `servletContainer`가 `init()`을 한 번만 호출하고 계속 재사용하는 구조로 보입니다. (코드를 확인해보세요. 보통 싱글톤입니다.)
    *   **공격 포인트:** "그렇다면 서블릿의 멤버 변수에 상태값(state)을 저장하면 어떤 문제가 생기나요?"
    *   **답변:** Thread-Safe하지 않게 됩니다. 여러 스레드가 동시에 `service()`를 호출하므로 멤버 변수 공유 시 데이터 꼬임이 발생합니다. 지역 변수나 `ThreadLocal`을 써야 합니다.

### 2-2. [Thread Pool] 스레드 모델과 성능
피드백: *"thread pool 설정도 잘 적용되었습니다."*

*   **Q1. `Executors.newFixedThreadPool`을 사용하셨는데, 스레드 개수는 어떻게 산정했나요?**
    *   **답변 가이드:** CPU 코어 수, I/O 대기 시간 등을 고려해야 합니다. I/O 작업(DB, 파일 읽기)이 많다면 코어 수보다 넉넉하게 잡고, CPU 연산이 많다면 코어 수와 비슷하게 잡습니다. 과제에서는 안정성을 위해 고정된 수치(예: 200 or 설정을 따름)를 사용했습니다.
*   **Q2. 현재 구조(BIO, Blocking I/O)의 한계점은 무엇인가요?**
    *   **답변:** 스레드 1개가 클라이언트 1개를 담당합니다(`1 Request per Thread`). 사용자가 늘어나면 스레드도 계속 늘려야 하는데, 스레드 생성 비용과 Context Switching 비용이 커져서 성능 저하가 옵니다. 스레드 풀이 꽉 차면 대기열(Queue)에 쌓여 응답이 지연됩니다.
    *   **개선안:** 이를 해결하려면 **NIO (Non-blocking I/O)** 방식이나 **Netty** 같은 비동기 프레임워크를 도입하여, 소수의 스레드로 다수의 연결을 처리(Event Loop)해야 합니다.

### 2-3. [SecurityRule] 디자인 패턴
피드백: *"SecurityRule를 통해 추상화를 정말 잘 해주셨습니다."*

*   **Q1. 이 구조의 장점은 무엇인가요?**
    *   **답변:** 새로운 보안 규칙(예: SQL Injection 방지)이 필요할 때, 기존 `HttpServer`나 `SecurityValidator` 코드를 수정할 필요 없이 `SecurityRule` 구현체만 추가하면 됩니다. 이는 **OCP(Open-Closed Principle)**를 준수한 설계입니다.

---

## 3. 라이브 코딩 (2시간) & 프리테스트 (30분) 대비

**T인터뷰**는 직무 관련 인터뷰이므로, 알고리즘 문제보다는 **"제출한 과제를 확장하는 기능 구현"**일 확률이 매우 높습니다.

### 3-1. 예상되는 라이브 코딩 과제 (WAS 확장)
2시간 동안 다음 기능을 추가하라고 할 수 있습니다.

1.  **Session / Cookie 구현**
    *   "로그인 기능을 만드시오."
    *   `Map<String, Session>` 형태로 세션 저장소(In-memory)를 만들고, `JSESSIONID` 쿠키를 파싱해서 매핑하는 로직.
2.  **Filter Chain 구현**
    *   현재 `SecurityRule`은 보안만 담당하지만, 범용적인 `Filter` 인터페이스를 만들어 로깅, 인코딩 변환 등을 처리하도록 리팩토링.
3.  **GET/POST 외의 메서드 지원 또는 Query Parameter 파싱 개선**
    *   `Request` 객체에서 쿼리 파라미터(`?name=gudrms`)를 `Map`으로 파싱하는 유틸리티 구현.
4.  **동적 HTML 렌더링 (Template Engine 흉내)**
    *   HTML 파일 내의 `{{userName}}` 같은 플레이스홀더를 실제 데이터로 치환하는 기능.

### 3-2. 대비 전략
*   **코드 흐름 완벽 숙지:** `clientSocket.accept()` → `RequestHandler` → `HttpRequest` 파싱 → `SecurityCheck` → `Servlet.service()` → `HttpResponse` 전송 과정을 머릿속에 그려두세요.
*   **빠른 구현:** "세션 만드세요" 하면 `ConcurrentHashMap`으로 바로 세션 매니저를 만들 수 있어야 합니다.

---

## 4. 결론 (합격 가능성?)

**긍정적 신호입니다.**
과제 피드백에서 "나빴던 점"이 없고 구조적 설계(추상화)를 칭찬했다는 것은, **기본기(객체지향, 스레드 관리)**가 탄탄하다고 평가받은 것입니다.

**합격의 열쇠는 T인터뷰(라이브 코딩 + 기술 면접)입니다.**
남은 기간 동안:
1.  **내 코드 다시 짜보기:** 안 보고 `HttpRequest`, `HttpResponse` 파싱 로직이나 `ThreadPool` 연결 부분을 짤 수 있는지 연습하세요.
2.  **질문 방어:** 위에서 언급한 "싱글톤 문제", "BIO 한계" 등에 대해 답변을 준비하세요.

충분히 합격 가능한 상태이시니 자신감을 가지셔도 됩니다! 파이팅입니다.
